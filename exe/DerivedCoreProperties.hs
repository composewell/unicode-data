 -- |
-- Module      : Script to parse ucd/DerivedCoreProperties.txt
--               to Haskell data structures
--
--               (c) 2020 Composewell Technologies
--
-- License     : BSD-3-Clause
-- Maintainer  : streamly@composewell.com
-- Stability   : experimental

module DerivedCoreProperties where

import Data.Char (isSpace)
import Data.List (isInfixOf, intersperse)
import Data.Function ((&))
import Streamly.Internal.Data.Fold (Fold(..))

import qualified Streamly.Prelude as S
import qualified Streamly.Internal.Data.Fold as FL
import qualified Streamly.Internal.FileSystem.Handle as H
import qualified Streamly.Internal.Data.Unicode.Stream as U
import qualified System.IO as Sys

import Streamly
import Common

-- # Derived Property: Uppercase
-- ...
--
-- # Derived Property: Alphabetic
-- # Generated from: Uppercase + Lowercase ...
-- # ...
--
-- 0041..005A    ; Alphabetic # L& ...
-- 0061..007A    ; Alphabetic # L& ...
-- 00AA          ; Alphabetic # Lo ...
--
-- # Derived Property: Lowercase
-- ...

parseProperty :: Monad m => Fold m String (String, [Int])
parseProperty = Fold step initial extract

    where

    initial = return Nothing

    extract Nothing = return ("", [])
    extract (Just x) = return x

    step Nothing str
        | isInfixOf "Derived Property" str =
            return $ Just (extractPropertyName str, [])
        | otherwise = return Nothing
    step st [] = return st
    step st (x:_)
        | x == '#' = return st
    step (Just (name, ordList)) str =
        return $ Just $ (name, ordList ++ (parseRange . getRange) str)

    extractPropertyName :: String -> String
    extractPropertyName str =
        dropWhile (/= ':') str & tail & dropWhile isSpace
          & takeWhile (not . isSpace)

    getRange :: String -> String
    getRange = takeWhile (not . isSpace) . takeWhile (/= ';')

    parseRange :: String -> [Int]
    parseRange rng =
        if (elem '.' rng)
        then let low = read $ "0x" ++ takeWhile (/= '.') rng
                 high =
                     read $ "0x" ++ reverse (takeWhile (/= '.') (reverse rng))
              in [low .. high]
        else [read $ "0x" ++ rng]

prop2FuncName :: String -> String
prop2FuncName x = "is" ++ x

createPropertyBitmaps ::
       (IsStream t, Monad m) => [String] -> t m String -> t m String
createPropertyBitmaps propNames lineStream =
    S.splitOn isDivider parseProperty lineStream
      & S.filter (\(name, _) -> name `elem` propNames)
      & S.map (\(name, ordList) -> genBitmap (prop2FuncName name) ordList)
      & S.map ((:) '\n')

    where

    isDivider x = x == "# ================================================"

genCoreProperties :: [String] -> FilePath -> FilePath -> IO ()
genCoreProperties [] _ _ = print "Empty property list"
genCoreProperties props inDir outDir = do
    inH <- Sys.openFile inFile Sys.ReadMode
    outH <- Sys.openFile outFile Sys.WriteMode
    Sys.hPutStr outH preface
    S.unfold H.read inH & U.decodeUtf8 & U.lines FL.toList
      & createPropertyBitmaps props
      & S.concatMap S.fromList
      & U.encodeUtf8
      & S.fold (H.write outH)
-- XXX Use this instead of concatMap?
--      & S.mapM Sys.hPutStrLn
--      & S.drain
    Sys.hClose inH
    Sys.hClose outH
  where
    inFile = inDir <> "/" <> "DerivedCoreProperties.txt"
    outFile = outDir <> "/" <> "Core.hs"
    exportList = unwords $ intersperse "," $ map prop2FuncName props
    preface = unlines
        [ "-- autogenerated from Unicode data"
        , "{-# LANGUAGE MagicHash #-}"
        , "module Data.Unicode.Properties.Core"
        , "(" ++ exportList ++ ")"
        , "where"
        , ""
        , "import Data.Char (ord)"
        , "import Data.Unicode.Internal.Bits (lookupBit64)"
        ]
