-- |
-- Copyright   : (c) 2024 Pierre Le Marre
-- License     : Apache-2.0
-- Maintainer  : streamly@composewell.com
-- Stability   : experimental
--
module UCD2Haskell.Generator
    ( -- * Recipe
      FileRecipe(..)
      -- * Generator
    , UnicodeSourceType(..)
    , runGenerator
    , moduleToFileName
    , dirFromFileName
      -- * Bitmap
    , BitmapType(..)
    , genBitmap
    , genEnumBitmap
    , bitMapToAddrLiteral
    , enumMapToAddrLiteral8
    , chunkAddrLiteral
    , word32ToWord8s
    , splitPlanes
    , ShamochuCode(..)
    , genBitmapShamochu
    , genEnumBitmapShamochu
    , generateShamochuBitmaps
    , toLookupBitMapName
      -- * Helpers
    , printCpuTime
    , unlinesBB
    , unwordsBB
    , apacheLicense
    , mkImports
    , (<+>)
    , mkImports'
    ) where

import Data.Bifunctor (Bifunctor (..))
import Data.Bits (Bits (..), FiniteBits (..))
import qualified Data.ByteString as B
import qualified Data.ByteString.Builder as BB
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Short as BS
import Data.Char (chr, isAlpha, toUpper)
import Data.Fixed (Centi)
import qualified Data.List as L
import qualified Data.List.NonEmpty as NE
import Data.Maybe (mapMaybe)
import Data.Ratio ((%))
import qualified Data.Set as Set
import Data.String (IsString (..))
import Data.Version (Version, makeVersion, showVersion)
import qualified Data.Vector.Unboxed as V
import Data.Word (Word32, Word8)
import Debug.Trace (trace)
import qualified GHC.Exts as Exts
import GHC.Stack (HasCallStack)
import qualified Shamochu
import System.CPUTime (getCPUTime)
import System.Directory (createDirectoryIfMissing)
import System.FilePath ((<.>), (</>))

import UCD2Haskell.Common (
    Fold,
    distribute,
    rmapFold,
    runFold,
    showB,
    showPaddedHeXB,
 )
import qualified Data.Map.Strict as Map

--------------------------------------------------------------------------------
-- Recipe
--------------------------------------------------------------------------------

data FileRecipe a
    = ModuleRecipe
      -- ^ A recipe to create a Haskell module file.
        { moduleName :: String
        -- ^ Module name
        , generateModule :: BB.Builder -> Fold a BB.Builder }
        -- ^ Function that generate the module, given the module name.
    -- May be useful someday
    -- TestOutputRecipe
    --   -- ^ A recipe to create a test output file.
    --     String
    --     -- ^ Test name
    --     (Fold a BB.Builder)
    --     -- ^ Test output generator

-- ModuleRecipe is a tuple of the module name and a function that generates the
-- module using the module name
type ModuleRecipe a = (String, BB.Builder -> Fold a BB.Builder)

type GeneratorRecipe a = [FileRecipe a]

--------------------------------------------------------------------------------
-- Generator
--------------------------------------------------------------------------------

data UnicodeSourceType = UCD | Security

moduleToFileName :: String -> String
moduleToFileName = map (\x -> if x == '.' then '/' else x)

dirFromFileName :: String -> String
dirFromFileName = reverse . dropWhile (/= '/') . reverse

moduleFileEmitter :: Version -> UnicodeSourceType -> FilePath -> FilePath -> ModuleRecipe a -> Fold a (IO ())
moduleFileEmitter version sourceType unicodeSourceFile outdir (modName, fldGen) =
    rmapFold action $ fldGen (BB.string7 modName)

    where

    pretext = mconcat
        $ "-- autogenerated from https://www.unicode.org/Public/"
        : case sourceType of
            Security | version < makeVersion [17, 0, 0] ->
                [ "security/"
                , BB.string7 (showVersion version)
                , "/"
                , BB.string7 unicodeSourceFile
                , "\n"
                ]
            _ ->
                [ BB.string7 (showVersion version)
                , case sourceType of
                    UCD -> "/ucd/"
                    Security -> "/security/"
                , BB.string7 unicodeSourceFile
                , "\n"
                ]
    outfile = outdir </> moduleToFileName modName <.> "hs"
    outfiledir = dirFromFileName outfile
    action c = do
        putChar '[' *> printCpuTime *> putStr "s] Writing module: "
        putStrLn modName
        createDirectoryIfMissing True outfiledir
        B.writeFile outfile (BL.toStrict (BB.toLazyByteString (pretext <> c)))

printCpuTime :: IO ()
printCpuTime = do
    t <- getCPUTime
    putStr (show (fromRational (t % 1000000000000) :: Centi))

runGenerator ::
       Version
    -> UnicodeSourceType
    -> FilePath
    -> FilePath
    -> (B.ByteString -> [a])
    -> FilePath
    -> [String]
    -> GeneratorRecipe a
    -> IO ()
runGenerator version sourceType indir file transformLines outdir patterns recipes = do
    raw <- B.readFile (indir </> file)
    sequence_ (runFold combinedFld (transformLines raw))

    where

    generatedFolds = mapMaybe toModuleEmitter recipes
    toModuleEmitter = \case
      ModuleRecipe name f -> if all (`L.isSubsequenceOf` name) patterns
        then Just (moduleFileEmitter version sourceType file outdir (name, f))
        else Nothing
    combinedFld = distribute generatedFolds

--------------------------------------------------------------------------------
-- Header
--------------------------------------------------------------------------------

apacheLicense
    :: Word   -- ^ Copyright year
    -> BB.Builder -- ^ Module name
    -> BB.Builder
apacheLicense year modName =
    unlinesBB
        [ "-- |"
        , "-- Module      : " <> modName
        , "-- Copyright   : (c) "
            <> BB.wordDec year
            <> " Composewell Technologies and Contributors"
        , "-- License     : Apache-2.0"
        , "-- Maintainer  : streamly@composewell.com"
        , "-- Stability   : experimental"
        ]

--------------------------------------------------------------------------------
-- Bitmaps
--------------------------------------------------------------------------------

-- | Deprecated, use 'genBitmapShamochu' instead
genBitmap :: HasCallStack => BB.Builder -> [Int] -> BB.Builder
genBitmap funcName ordList = mconcat
    [ "{-# INLINE " <> funcName <> " #-}\n"
    , funcName, " :: Char -> Bool\n"
    , funcName, func
    , "    !(Ptr bitmap#) = ", bitmapLookup, "\n\n"
    , bitmapLookup, " :: Ptr Word8\n"
    , bitmapLookup, " = Ptr\n"
    , "    \"", bitMapToAddrLiteral bitmap "\"#\n" ]
    where
    rawBitmap = positionsToBitMap ordList
    bitmapLookup = funcName <> "Bitmap"
    (func, bitmap) = if length rawBitmap <= 0x40000
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> let cp = ord c in cp >= 0x"
                , showPaddedHeXB (minimum ordList)
                , " && cp <= 0x"
                , showPaddedHeXB (maximum ordList)
                , " && lookupBit bitmap# cp\n"
                , "    where\n" ]
            , rawBitmap )
        -- Planes 0-3 and 14
        else
            let (planes0To3, plane14) = splitPlanes "genBitmap: cannot build" not rawBitmap
                bound0 = pred (minimum ordList)
                bound1 = length planes0To3
                bound2 = 0xE0000 + length plane14
            in ( mconcat
                    [ " c\n"
                    , if bound0 > 0
                        then mconcat
                            [ "    | cp < 0x"
                            , showPaddedHeXB bound0
                            , " = False\n" ]
                        else ""
                    , "    | cp < 0x", showPaddedHeXB bound1
                    , " = lookupBit bitmap# cp\n"
                    , "    | cp < 0xE0000 = False\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                    , " = lookupBit bitmap# (cp - 0x"
                    , showPaddedHeXB (0xE0000 - bound1)
                    , ")\n"
                    , "    | otherwise = False\n"
                    , "    where\n"
                    , "    cp = ord c\n" ]
                , planes0To3 <> plane14 )

{-|
>>> positionsToBitMap [0, 3, 8]
[True,False,False,True,False,False,False,False,True]
-}
positionsToBitMap :: [Int] -> [Bool]
positionsToBitMap = go 0

    where

    go _ [] = []
    go i xxs@(x:xs)
        | i < x = False : go (i + 1) xxs
        | otherwise = True : go (i + 1) xs

bitMapToAddrLiteral ::
  -- | Values to encode
  [Bool] ->
  -- | String to append
  BB.Builder ->
  BB.Builder
bitMapToAddrLiteral bs = chunkAddrLiteral 4 0xff encode (L.unfoldr mkChunks bs)

    where

    mkChunks :: [a] -> Maybe ([a], [a])
    mkChunks [] = Nothing
    mkChunks xs = Just $ splitAt 8 xs

    encode :: [Bool] -> BB.Builder -> BB.Builder
    encode chunk acc = BB.char7 '\\' <> BB.intDec (toByte (padTo8 chunk)) <> acc

    padTo8 :: [Bool] -> [Bool]
    padTo8 xs
        | length xs >= 8 = xs
        | otherwise = xs <> replicate (8 - length xs) False

    toByte :: [Bool] -> Int
    toByte xs = sum $ map (\i -> if xs !! i then 1 `shiftL` i else 0) [0..7]

splitPlanes :: (HasCallStack) => String -> (a -> Bool) -> [a] -> ([a], [a])
splitPlanes msg isDef xs = if all isDef planes4To13 && null planes15To16
    then (planes0To3, plane14)
    else error msg
    where
    planes0To3 = L.dropWhileEnd isDef (take 0x40000 xs)
    planes4To16 = drop 0x40000 xs
    planes4To13 = take (0xE0000 - 0x40000) planes4To16
    planes14To16 = drop (0xE0000 - 0x40000) planes4To16
    plane14 = L.dropWhileEnd isDef (take 0x10000 planes14To16)
    planes15To16 = drop 0x10000 planes14To16

-- | Deprecated, prefer 'genEnumBitmapShamochu'
genEnumBitmap
  :: forall a. (HasCallStack, Bounded a, Enum a, Eq a, Show a)
  => BB.Builder
  -- ^ Function name
  -> Bool
  -- ^ If true, use raw Int
  -> (a, BB.Builder)
  -- ^ Value for planes 15-16
  -> (a, BB.Builder)
  -- ^ Default value
  -> [a]
  -- ^ List of values to encode for planes 0 to 3
  -> [a]
  -- ^ List of values to encode for plane 14
  -> BB.Builder
genEnumBitmap funcName rawInt (defPUA, pPUA) (def, pDef) planes0To3 plane14 =
    mconcat
    [ "{-# INLINE ", funcName, " #-}\n"
    , funcName, " :: Char -> Int", rawSuffix, "\n"
    , funcName, func
    , "    !(Ptr bitmap#) = ", bitmapLookup, "\n\n"
    , bitmapLookup, " :: Ptr Word8\n"
    , bitmapLookup, " = Ptr\n"
    , "    \"", enumMapToAddrLiteral8 4 0xff bitmap "\"#"
    ]
    where
    rawSuffix = if rawInt then "#" else ""
    bitmapLookup = funcName <> "Bitmap"
    planes0To3' = L.dropWhileEnd (== def) planes0To3
    check = if length planes0To3 <= 0x40000
        then ()
        else error "genEnumBitmap: Cannot build"
    (func, bitmap) = check `seq` if null plane14 && defPUA == def
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> let cp = ord c in if cp >= 0x"
                , showPaddedHeXB (length planes0To3')
                , " then "
                , pDef, rawSuffix
                , " else lookupWord8AsInt", rawSuffix, " bitmap# cp\n"
                , "    where\n" ]
            , planes0To3' )
        -- All the planes
        else
            let plane14' = L.dropWhileEnd (== def) plane14
                bound1 = length planes0To3'
                bound2 = 0xE0000 + length plane14'
            in ( mconcat
                    [ " c\n"
                    , "    -- Planes 0-3\n"
                    , "    | cp < 0x", showPaddedHeXB bound1
                                     , " = lookupWord8AsInt", rawSuffix, " bitmap# cp\n"
                    , "    -- Planes 4-13: ", showB def, "\n"
                    , "    | cp < 0xE0000 = " <> pDef, rawSuffix, "\n"
                    , "    -- Plane 14\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                                     , " = lookupWord8AsInt", rawSuffix, " bitmap# (cp - 0x"
                                     , showPaddedHeXB (0xE0000 - bound1)
                                     , ")\n"
                    , if defPUA == def
                        then ""
                        else mconcat
                            [ "    -- Plane 14: ", showB def, "\n"
                            , "    | cp < 0xF0000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB defPUA, "\n"
                            , "    | cp < 0xFFFFE = ", pPUA, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB def, "\n"
                            , "    | cp < 0x100000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 16: ", showB defPUA, "\n"
                            , "    | cp < 0x10FFFE = ", pPUA, rawSuffix, "\n" ]
                    , "    -- Default: ", showB def, "\n"
                    , "    | otherwise = " <> pDef, rawSuffix, "\n"
                    , "    where\n"
                    , "    cp = ord c\n" ]
                , planes0To3' <> plane14' )

{-| Encode a list of values as a byte map, using their 'Enum' instance.

Specialization of 'enumMapToAddrLiteralN' using a single 'Word8' to encode
values.

>>> enumMapToAddrLiteral8 0 2 [(1 :: Word8), 2, 3] ""
"\\1\\2\\\n\\\\3"
>>> :{
enumMapToAddrLiteral8 0 2 [(1 :: Word8), 2, 3] "" ==
enumMapToAddrLiteralN 0 2 1 [(1 :: Word8), 2, 3] ""
:}
True

__Note:__ 'Enum' instance must respect the following:

* @fromEnum minBound >= 0x00@
* @fromEnum maxBound <= 0xff@
-}
enumMapToAddrLiteral8
  :: forall a. (Bounded a, Enum a, Show a)
  => Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
enumMapToAddrLiteral8 indentation chunkSize =
    chunkAddrLiteral indentation chunkSize addWord

    where

    addWord :: a -> BB.Builder -> BB.Builder
    addWord x acc = BB.char7 '\\' <> BB.word8Dec (toWord8 x) <> acc

    toWord8 :: a -> Word8
    toWord8 a = let w = fromEnum a in if 0 <= w && w <= 0xff
        then fromIntegral w
        else error $ "Cannot convert to Word8: " <> show a

-- | Encode a list of values as a byte map, using their 'Enum' instance.
--
-- Generalization of 'enumMapToAddrLiteral8'.
enumMapToAddrLiteralN
  :: forall a. (Bounded a, Enum a, Show a)
  => Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> Word
  -- ^ 'Word8's per value
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
enumMapToAddrLiteralN indentation chunkSize size =
    chunkAddrLiteral indentation chunkSize addWords

    where

    byteSize = finiteBitSize (0 :: Word8)

    upperBound = 1 `shiftL` (byteSize * fromIntegral size)

    addWords :: a -> BB.Builder -> BB.Builder
    addWords x acc = foldMap (\w -> BB.char7 '\\' <> BB.word8Dec w) (toWord8LEs x) <> acc

    toWord8LEs :: a -> [Word8]
    toWord8LEs a = let w = fromEnum a in if 0 <= w && w < upperBound
        then go size w
        else error $ "Cannot convert to Word8s: " <> show a <> " " <> show (size, upperBound)

    go :: Word -> Int -> [Word8]
    go 0 _ = []
    go k n = fromIntegral (n .&. 0xff) : go (k - 1) (n `shiftR` byteSize)

-- | Pretty-print 'Addr#' litterals
chunkAddrLiteral
  :: forall a. Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> (a -> BB.Builder -> BB.Builder)
  -- ^ Function to convert to 'Word8' and prepend to the accumulator
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
chunkAddrLiteral indentation chunkSize addWord xs cs
    = fst
    . foldr go (cs, NoIndent)
    $ chunksOf chunkSize xs

    where

    indent = indent' indentation . (BB.char7 '\\' <>)
    indent' = \case
        0 -> (BB.shortByteString "\\\n" <>)
        i -> indent' (pred i) . (BB.char7 ' ' <>)

    go :: [a] -> (BB.Builder, Indent) -> (BB.Builder, Indent)
    go as (acc, seps) = (foldr addWord (f acc) as, Indent)
        where
        f = case seps of
            NoIndent -> id
            Indent -> indent

data Indent = NoIndent | Indent

chunksOf :: Int -> [a] -> [[a]]
chunksOf i = go
    where
    go = \case
        [] -> []
        as -> b : go as'
            where (b, as') = splitAt i as

-- Encode Word32 to [Word8] little endian
word32ToWord8s :: Word32 -> [Word8]
word32ToWord8s n = (\k -> fromIntegral ((n `shiftR` k) .&. 0xff)) <$> [0,8..24]

--------------------------------------------------------------------------------
-- Bitmaps: Shamochu algorithm
--------------------------------------------------------------------------------

-- | Given a list of /boolean/ denoted by the index of the 'True' values, create
-- the corresponding efficient lookup function.
genBitmapShamochu ::
     HasCallStack
  => String
  -> NE.NonEmpty Word
  -- ^ Chunk size stage 1
  -> [Word]
  -- ^ Chunk size stage 2
  -> [Int]
  -- ^ List of boolean 'True' denoted by their index
  -> ShamochuCode
genBitmapShamochu funcNameStr stage1 stage2 ordList = ShamochuCode
    { code = mconcat
        [ "{-# INLINE " <> funcName <> " #-}\n"
        , funcName, " :: Char -> Bool\n"
        , funcName, func
        , "\n"
        , code
        ]
    , imports = imports }
    where
    funcName = BB.string7 funcNameStr
    rawBitmap = positionsToBitMap ordList
    lookupFunc = toLookupBitMapName funcNameStr

    -- Because data is sparse and repetitive, lookup has 2 steps:
    -- 1. Get the offset corresponding to the plane, or a default value if the
    --    plane has only the default value.
    -- 2. If we get an offset, then lookup the value in the Shamochu-compressed
    --    dataset.

    -- Given multiple data sets for planes, combine them into a single
    -- data set and create the corresponding lookup function.
    (func, bitmap) = if length rawBitmap <= 0x40000
        -- Only planes 0-3
        then
            ( mconcat
                [ " c = c >= '\\x"
                , showPaddedHeXB (minimum ordList)
                , "' && c <= '\\x"
                , showPaddedHeXB (maximum ordList)
                , "' && ", lookupFunc, " (ord c)\n" ]
            , rawBitmap )
        -- Planes 0-3 and 14
        else
            let (planes0To3, plane14) = splitPlanes "genBitmapShamochu: cannot build" not rawBitmap
                bound0 = pred (minimum ordList)
                bound1 = length planes0To3
                bound2 = 0xE0000 + length plane14
            in ( mconcat
                    [ " c\n"
                    , if bound0 > 0
                        then mconcat
                            [ "    | c < '\\x"
                            , showPaddedHeXB bound0
                            , "' = False\n" ]
                        else ""
                    , "    | c < '\\x", showPaddedHeXB bound1
                    , "' = ", lookupFunc, " (ord c)\n"
                    , "    | c < '\\xE0000' = False\n"
                    , "    | c < '\\x", showPaddedHeXB bound2
                    , "' = ", lookupFunc, " (ord c - 0x"
                    , showPaddedHeXB (0xE0000 - bound1)
                    , ")\n"
                    , "    | otherwise = False\n"
                    ]
                , planes0To3 <> plane14 )
    -- Given a list of values, create efficient lookup function using Shamochu
    ShamochuCode{..} = generateShamochuBitmaps
                            funcNameStr
                            False
                            BitMap
                            stage1
                            stage2
                            id
                            (packBits bitmap)

{-|
>>> packBits [True, False, False, False, False, False, False, False, False, True]
[1,2]
-}
packBits :: [Bool] -> [Word8]
packBits = L.unfoldr go
    where
    go :: [Bool] -> Maybe (Word8, [Bool])
    go [] = Nothing
    go xs = Just . first pack . splitAt 8 $ xs

    pack :: [Bool] -> Word8
    pack = toByte . padTo8

    padTo8 :: [Bool] -> [Bool]
    padTo8 xs
        | length xs >= 8 = xs
        | otherwise = xs <> replicate (8 - length xs) False

    toByte :: [Bool] -> Word8
    toByte xs = sum $ map (\i -> if xs !! i then 1 `shiftL` i else 0) [0..7]

-- | Given a list of values from an /enumeration/, create the corresponding
-- efficient lookup function.
genEnumBitmapShamochu
  :: forall a b. ( HasCallStack, Eq a, Show a
                 , FiniteBits b, V.Unbox b, Enum b, Bounded b, Ord b, Num b, Show b)
  => String
  -- ^ Function name
  -> Bool
  -- ^ If true, use raw Int
  -> NE.NonEmpty Word
  -- ^ Chunk size stage 1
  -> [Word]
  -- ^ Chunk size stage 2
  -> (a -> b)
  -- ^ Conversion
  -> (a, BB.Builder)
  -- ^ Value for planes 15-16
  -> (a, BB.Builder)
  -- ^ Default value
  -> [a]
  -- ^ List of values to encode for planes 0 to 3
  -> [a]
  -- ^ List of values to encode for plane 14
  -> ShamochuCode
genEnumBitmapShamochu funcNameStr rawInt stage1 stage2 convert (defPUA, pPUA) (def, pDef) planes0To3 plane14 =
    ShamochuCode
        { code = mconcat
            [ "{-# INLINE ", funcName, " #-}\n"
            , funcName, " :: Char -> Int", rawSuffix, "\n"
            , funcName, func
            , "\n"
            , code
            ]
        , imports = imports }
    where
    rawSuffix = if rawInt then "#" else ""
    funcName = BB.string7 funcNameStr
    lookupFunc = toLookupBitMapName funcNameStr
    planes0To3' = L.dropWhileEnd (== def) planes0To3
    check = if length planes0To3 <= 0x40000
        then ()
        else error "genEnumBitmapShamochu: Cannot build"

    -- Because data is sparse and repetitive, lookup has 2 steps:
    -- 1. Get the offset corresponding to the plane, or a default value if the
    --    plane has only the default value.
    -- 2. If we get an offset, then lookup the value in the Shamochu-compressed
    --    dataset.

    -- Given multiple data sets for planes, combine them into a single
    -- data set and create the corresponding lookup function.
    (func, bitmap) = check `seq` if null plane14 && defPUA == def
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> if c >= '\\x"
                , showPaddedHeXB (length planes0To3')
                , "' then "
                , pDef, rawSuffix
                , " else ", lookupFunc, " (ord c)\n" ]
            , planes0To3' )
        -- All the planes
        else
            let plane14' = L.dropWhileEnd (== def) plane14
                bound1 = length planes0To3'
                bound2 = 0xE0000 + length plane14'
            in ( mconcat
                    [ " c\n"
                    , "    -- Planes 0-3\n"
                    , "    | cp < 0x", showPaddedHeXB bound1
                                     , " = ", lookupFunc, " cp", rawSuffix, "\n"
                    , "    -- Planes 4-13: ", showB def, "\n"
                    , "    | cp < 0xE0000 = " <> pDef, rawSuffix, "\n"
                    , "    -- Plane 14\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                                     , " = ", lookupFunc, " (cp", rawSuffix
                                     , " -", rawSuffix, " 0x"
                                     , showPaddedHeXB (0xE0000 - bound1), rawSuffix
                                     , ")\n"
                    , if defPUA == def
                        then ""
                        else mconcat
                            [ "    -- Plane 14: ", showB def, "\n"
                            , "    | cp < 0xF0000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB defPUA, "\n"
                            , "    | cp < 0xFFFFE = ", pPUA, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB def, "\n"
                            , "    | cp < 0x100000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 16: ", showB defPUA, "\n"
                            , "    | cp < 0x10FFFE = ", pPUA, rawSuffix, "\n" ]
                    , "    -- Default: ", showB def, "\n"
                    , "    | otherwise = " <> pDef, rawSuffix, "\n"
                    , "    where\n"
                    , "    ", if rawInt then "!cp@(I# cp#)" else "cp", " = ord c\n" ]
                , planes0To3' <> plane14' )
    -- Given a list of values, create efficient lookup function using Shamochu
    ShamochuCode{..} = generateShamochuBitmaps
                            funcNameStr
                            rawInt
                            ByteMap
                            stage1
                            stage2
                            convert
                            bitmap

data BitmapType = BitMap | ByteMap
-- | Module → imported items map
type Imports = Map.Map BS.ShortByteString (Set.Set BS.ShortByteString)

data ShamochuCode = ShamochuCode
    { code :: !BB.Builder
    , imports :: !Imports }

instance Semigroup ShamochuCode where
    ShamochuCode c1 i1 <> ShamochuCode c2 i2 =
        ShamochuCode (c1 <> "\n" <> c2) (i1 <+> i2)

instance Monoid ShamochuCode where
    mempty = ShamochuCode mempty mempty

-- | Given a list of values, create a time- and space-efficient lookup function
generateShamochuBitmaps ::
    forall a b. (FiniteBits b, V.Unbox b, Enum b, Bounded b, Ord b, Num b, Show b) =>
    -- | Name of the function
    String ->
    -- | Use raw 'Int#' if true
    Bool ->
    -- | Type
    BitmapType ->
    -- | Chunk sizes stage 1
    NE.NonEmpty Word ->
    -- | Chunk sizes stage 2
    [Word] ->
    -- | Conversion function
    (a -> b) ->
    -- | Input
    [a] ->
    -- | Bitmaps Haskell code and import list
    ShamochuCode
generateShamochuBitmaps name rawInt mapType powersStage1 powersStage2 convert xs =
    case Shamochu.compress powersStage1 powersStage2 xs' of
        Shamochu.OneStage{..} -> trace' "OneStage" stats $ ShamochuCode{..}
            where
            code = mconcat
                [ "{-# INLINE ", toLookupBitMapName name, " #-}\n"
                , toLookupBitMapName name, " :: Int", rawSuffix, " -> ", outputType, "\n"
                , toLookupBitMapName name, " n =\n"
                -- Lookup:
                --    mask = (1 << chunk_size_log2) - 1;
                --    original[i] = data[offsets[i >> chunk_size_log2] + (i & mask)];
                , case mapType of
                    BitMap -> mkBitLookup "data" 1 . mconcat $
                        [ mkWordLookup (Shamochu.offsets1IntSize stats) "offsets" 2 $
                            mkIndent 3 <> mkShiftR "n" (byteBitSizeLog2 + Shamochu.dataChunkSizeLog2 stats)
                        , mkAnd (mkShiftR' "n" byteBitSizeLog2) "mask" ]
                    ByteMap -> mkWordLookup (Shamochu.dataIntSize stats) "data" 1 . mconcat $
                        [ mkWordLookup (Shamochu.offsets1IntSize stats) "offsets" 2 $
                            mkIndent 3 <> mkShiftR "n" (Shamochu.dataChunkSizeLog2 stats)
                        , mkAnd "n" "mask" ]
                , "\n"
                , "    where\n"
                , "    ", mkMaskDef "mask" (Shamochu.dataChunkSizeLog2 stats)
                , "    !(Ptr data#) = ", dataBitMap, "\n"
                , "    !(Ptr offsets#) = ", offsetsBitMap, "\n"
                , "\n"
                , dataBitMap, " :: Ptr ", dataType, "\n"
                , dataBitMap, " = Ptr\n"
                , "    \"", enumMapToAddrLiteralN
                                4
                                50
                                (Shamochu.dataIntSize stats `shiftR` byteBitSizeLog2)
                                (pad (Exts.toList array))
                                "\"#\n"
                , "\n"
                , offsetsBitMap, " :: Ptr ", offsetType, "\n"
                , offsetsBitMap, " = Ptr\n"
                , "    \"", enumMapToAddrLiteralN
                                4
                                50
                                (Shamochu.offsets1IntSize stats `shiftR` byteBitSizeLog2)
                                (Exts.toList offsets)
                                "\"#\n"
                ]
            imports = case mapType of
                BitMap
                    | rawInt -> error "unsupported"
                    | otherwise -> defaultBitMapImports
                                        (Shamochu.offsets1IntSize stats)
                               <+> defaultByteMapImportsBoxed
                ByteMap
                    | rawInt -> defaultByteMapImports
                                    (Shamochu.dataIntSize stats)
                                    (Shamochu.offsets1IntSize stats)
                            <+> defaultByteMapImportsUnboxed
                    | otherwise -> defaultByteMapImports
                                        (Shamochu.dataIntSize stats)
                                        (Shamochu.offsets1IntSize stats)
                               <+> defaultByteMapImportsBoxed
            Shamochu.CompressedArray{..} = array1
            dataBitMap = nameBB <> "DataBitMap"
            offsetsBitMap = nameBB <> "OffsetsBitMap"
            dataType = "Int" <> BB.wordDec (Shamochu.dataIntSize stats)
            offsetType = "Word" <> BB.wordDec (Shamochu.offsets1IntSize stats)
        Shamochu.TwoStages{..} -> trace' "TwoStages" stats $ ShamochuCode{..}
            where
            code = mconcat
                [ "{-# INLINE ", toLookupBitMapName name, " #-}\n"
                , toLookupBitMapName name, " :: Int", rawSuffix, " -> ", outputType, "\n"
                , toLookupBitMapName name, " n =\n"
                -- Lookup:
                --    mask_data = (1 << data_chunk_size_log2) - 1
                --    mask_offsets = (1 << offsets_chunk_size_log2) - 1
                --    data[
                --        offsets1[
                --            offsets2[i >> (data_chunk_size_log2 + offsets_chunk_size_log2)] +
                --            ((i >> data_chunk_size_log2) & mask_offsets)
                --        ] +
                --        (i & mask_data)
                --    ];
                , case mapType of
                    BitMap -> mkBitLookup "data" 1 . mconcat $
                        [ mkWordLookup (Shamochu.offsets1IntSize stats) "offsets1" 2 . mconcat $
                            [ mkWordLookup (Shamochu.offsets2IntSize stats) "offsets2" 3 $
                                mkIndent 4 <>
                                mkShiftR "n" (byteBitSizeLog2 + Shamochu.dataChunkSizeLog2 stats + Shamochu.offsets1ChunkSizeLog2 stats)
                            , mkAnd (mkShiftR' "n" (byteBitSizeLog2 + Shamochu.dataChunkSizeLog2 stats)) "maskOffsets"
                            ]
                        , mkAnd (mkShiftR' "n" byteBitSizeLog2) "maskData" ]
                    ByteMap -> mkWordLookup (Shamochu.dataIntSize stats) "data" 1 . mconcat $
                        [ mkWordLookup (Shamochu.offsets1IntSize stats) "offsets1" 2 . mconcat $
                            [ mkWordLookup (Shamochu.offsets2IntSize stats) "offsets2" 3 $
                                mkIndent 4 <>
                                mkShiftR "n" (Shamochu.dataChunkSizeLog2 stats + Shamochu.offsets1ChunkSizeLog2 stats)
                            , mkAnd (mkShiftR' "n" (Shamochu.dataChunkSizeLog2 stats)) "maskOffsets"
                            ]
                        , mkAnd "n" "maskData" ]
                , "\n"
                , "    where\n"
                , "    ", mkMaskDef "maskData" (Shamochu.dataChunkSizeLog2 stats)
                , "    ", mkMaskDef "maskOffsets" (Shamochu.offsets1ChunkSizeLog2 stats)
                , "    !(Ptr data#) = ", dataBitMap, "\n"
                , "    !(Ptr offsets1#) = ", offsets1BitMap, "\n"
                , "    !(Ptr offsets2#) = ", offsets2BitMap, "\n"
                , "\n"
                , dataBitMap, " :: Ptr ", dataType, "\n"
                , dataBitMap, " = Ptr\n"
                , "    \"", enumMapToAddrLiteralN
                                4
                                50
                                (Shamochu.dataIntSize stats `shiftR` byteBitSizeLog2)
                                (pad (Exts.toList dataArray))
                                "\"#\n"
                , "\n"
                , offsets1BitMap, " :: Ptr ", offset1Type, "\n"
                , offsets1BitMap, " = Ptr\n"
                , "    \"", enumMapToAddrLiteralN
                                4
                                50
                                (Shamochu.offsets1IntSize stats `shiftR` byteBitSizeLog2)
                                (Exts.toList offset1Array)
                                "\"#\n"
                , "\n"
                , offsets2BitMap, " :: Ptr ", offset2Type, "\n"
                , offsets2BitMap, " = Ptr\n"
                , "    \"", enumMapToAddrLiteralN
                                4
                                50
                                (Shamochu.offsets2IntSize stats `shiftR` byteBitSizeLog2)
                                (Exts.toList offsets2Array)
                                "\"#\n"
                ]
            imports = case mapType of
                BitMap
                    | rawInt -> error "unsupported"
                    | otherwise -> defaultBitMapImports
                                        (Shamochu.offsets1IntSize stats)
                               <+> wordImport (Shamochu.offsets2IntSize stats)
                               <+> lookupFuncImport (Shamochu.offsets2IntSize stats)
                               <+> defaultByteMapImportsBoxed
                ByteMap
                    | rawInt -> defaultByteMapImports
                                    (Shamochu.dataIntSize stats)
                                    (Shamochu.offsets1IntSize stats)
                            <+> wordImport (Shamochu.offsets2IntSize stats)
                            <+> lookupFuncImport (Shamochu.offsets2IntSize stats)
                            <+> defaultByteMapImportsUnboxed
                    | otherwise -> defaultByteMapImports
                                        (Shamochu.dataIntSize stats)
                                        (Shamochu.offsets1IntSize stats)
                               <+> wordImport (Shamochu.offsets2IntSize stats)
                               <+> lookupFuncImport (Shamochu.offsets2IntSize stats)
                               <+> defaultByteMapImportsBoxed
            Shamochu.CompressedArray{array=dataArray} = array1
            Shamochu.CompressedArray{array=offset1Array, offsets=offsets2Array} = array2
            dataBitMap = nameBB <> "DataBitMap"
            offsets1BitMap = nameBB <> "Offsets1BitMap"
            offsets2BitMap = nameBB <> "Offsets2BitMap"
            dataType = "Int" <> BB.wordDec (Shamochu.dataIntSize stats)
            offset1Type = "Word" <> BB.wordDec (Shamochu.offsets1IntSize stats)
            offset2Type = "Word" <> BB.wordDec (Shamochu.offsets2IntSize stats)
    where
    xs' = Exts.fromList (convert <$> xs)
    nameBB = BB.string7 name

    -- Integer types sizes: byte
    byteBitSize = finiteBitSize (0 :: Word8)
    byteBitSizeLog2 :: (Integral bs) => bs
    byteBitSizeLog2 = log2 (fromIntegral byteBitSize)

    -- Integer types sizes: encoded value
    maxWordBitSizeLog2 = log2 (fromIntegral (finiteBitSize (0 :: b)))
    maxWordByteSize = if any (< maxWordBitSizeLog2) powersStage1
        then error "Chunks should not cut words"
        else 2 ^ (maxWordBitSizeLog2 - byteBitSizeLog2)

    -- Helper for correct Addr# literal
    pad ys = case mapType of
        -- Ensure lookupBit read full words at the edge
        BitMap -> case rem (length ys) maxWordByteSize of
            0 -> ys
            k -> ys <> replicate (maxWordByteSize - k) 0
        ByteMap -> ys

    -- Lookup functions
    outputType = case mapType of
        BitMap -> "Bool"
        ByteMap -> if rawInt then "Int#" else "Int"
    rawSuffix = if rawInt then "#" else ""
    mkBitLookup addrName indent index = mconcat
        [ mkIndent indent
        , "lookupBit", rawSuffix, " ", addrName, "# (\n"
        , index, "\n"
        , mkIndent indent
        , ") (n "
        -- x % 2^n = x & (2^n - 1)
        , if rawInt then "`andI#` 7#)" else ".&. 7)" ]
    mkWordLookup dataSize addrName indent index = mconcat
        [ mkIndent indent
        , "lookupWord", BB.wordDec dataSize, "AsInt", rawSuffix
        , " ", addrName, "# (\n"
        , index, "\n"
        , mkIndent indent, ")" ]
    mkWord dataSize = "Word" <> fromString (show dataSize)
    mkInt dataSize = "Int" <> fromString (show dataSize)
    mkMaskDef mask count = if rawInt
        then mconcat [mask, " = (1# `iShiftL#` ", BB.wordDec count, "#) -# 1#\n"]
        else mconcat [mask, " = (1 `shiftL` ", BB.wordDec count, ") - 1\n"]
    mkMask n mask = if rawInt
        then mconcat ["(", n, " `andI#` ", mask, ")"]
        else mconcat ["(", n, " .&. ", mask, ")"]
    mkAnd n mask = (if rawInt then " +# " else " + ") <> mkMask n mask
    mkShiftR n count = if rawInt
        then mconcat [n, " `iShiftRL#` ", BB.wordDec count, "#"]
        else mconcat [n, " `shiftR` ", BB.wordDec count]
    mkShiftR' n count = "(" <> mkShiftR n count <> ")"
    mkIndent :: Word -> BB.Builder
    mkIndent count = foldMap (const "    ") [1..count]

    -- Imports
    defaultBitMapImports offsetsSize = Map.fromList
        [ ( "Data.Char", Set.singleton "ord" )
        , ( "Data.Int", Set.singleton "Int8" )
        , ( "Data.Word", Set.singleton (mkWord offsetsSize) )
        , ( "GHC.Exts", Set.singleton "Ptr(..)" )
        , ( "Unicode.Internal.Bits"
          , Set.fromList
                [ "lookupBit"
                , mkWordLookupFunc offsetsSize ]
            )
        ]
    defaultByteMapImports dataSize offsetsSize = Map.fromList
        [ ( "Data.Char", Set.singleton "ord" )
        , ( "Data.Int", Set.singleton (mkInt dataSize) )
        , ( "Data.Word", Set.singleton (mkWord offsetsSize) )
        , ( "GHC.Exts", Set.singleton "Ptr(..)" )
        , ( "Unicode.Internal.Bits"
          , Set.fromList
                [ mkWordLookupFunc dataSize
                , mkWordLookupFunc offsetsSize ]
          )
        ]
    defaultByteMapImportsBoxed = Map.singleton
        "Data.Bits"
        (Set.singleton "Bits(..)")
    defaultByteMapImportsUnboxed = Map.singleton
        "GHC.Exts"
        (Set.fromList ["Int#", "andI#", "iShiftL#", "iShiftRL#", "(+#)", "(-#)"])
    wordImport w = Map.singleton "Data.Word" (Set.singleton (mkWord w))
    lookupFuncImport size = Map.singleton
        "Unicode.Internal.Bits"
        (Set.singleton (mkWordLookupFunc size))
    mkWordLookupFunc dataSize = mconcat
        [ "lookupWord"
        , fromString (show dataSize)
        , "AsInt"
        , if rawInt then "#" else "" ]

    -- Debug
    trace' stages stats = trace $ mconcat
        [ "* ", name, ": Shamochu: ", stages, "; savings: "
        , show (fromRational (100 * (1 - 1 / toRational (Shamochu.ratio stats))) :: Centi)
        , "%; "
        , show stats ]

toLookupBitMapName :: String -> BB.Builder
toLookupBitMapName name = "lookup" <> BB.string7 (toTitle name) <> "BitMap"

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

{-# INLINE log2 #-}
log2 :: (Integral n) => Word -> n
log2 a = fromIntegral (finiteBitSize (0 :: Word) - 1 - countLeadingZeros a)

toTitle :: String -> String
toTitle = \case
    c:cs -> toUpper c : cs
    cs -> cs

unlinesBB :: [BB.Builder] -> BB.Builder
unlinesBB = (<> "\n") . mconcat . L.intersperse "\n"

unwordsBB :: [BB.Builder] -> BB.Builder
unwordsBB = mconcat . L.intersperse " "

mkImports :: Imports -> BB.Builder
mkImports = Map.foldMapWithKey \module_ xs -> mconcat
    [ "import ", BB.shortByteString module_, " ("
    , foldMap BB.shortByteString
        ( L.intersperse ", "
        . fmap getImportItem
        . Set.toAscList
        . Set.map ImportItem
        $ xs )
    , ")\n" ]

-- | Make operators appear last
newtype ImportItem = ImportItem { getImportItem :: BS.ShortByteString }
    deriving newtype (Eq)

instance Ord ImportItem where
    ImportItem i1 `compare` ImportItem i2 = case compare (isOperator i1) (isOperator i2) of
        EQ -> compare i1 i2
        cmp -> cmp
        where
        isOperator i = case BS.unpack i of
            [] -> False
            w:_ -> not (isAlpha (chr (fromIntegral w)))

mkImports' :: BS.ShortByteString -> Imports -> BB.Builder
mkImports' p = mkImports . Map.mapKeys \case
    "Unicode.Internal.Bits" -> "Unicode.Internal.Bits." <> p
    k -> k

(<+>) :: (Ord k, Semigroup v) => Map.Map k v -> Map.Map k v -> Map.Map k v
(<+>) = Map.unionWith (<>)
