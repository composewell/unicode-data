-- |
-- Copyright   : (c) 2024 Pierre Le Marre
-- License     : Apache-2.0
-- Maintainer  : streamly@composewell.com
-- Stability   : experimental
--
module UCD2Haskell.Generator
    ( -- * Recipe
      FileRecipe(..)
      -- * Generator
    , runGenerator
    , moduleToFileName
    , dirFromFileName
      -- * Bitmap
    , genBitmap
    , genEnumBitmap
    , bitMapToAddrLiteral
    , enumMapToAddrLiteral
    , chunkAddrLiteral
    , word32ToWord8s
    , splitPlanes
    , genEnumBitmapShamochu
    , generateShamochuBitmaps
    , toLookupBitMapName
      -- * Helpers
    , printCpuTime
    , unlinesBB
    , unwordsBB
    , apacheLicense
    ) where

import Data.Bits (Bits (..))
import qualified Data.ByteString as B
import qualified Data.ByteString.Builder as BB
import qualified Data.ByteString.Lazy as BL
import Data.Char (toUpper)
import Data.Fixed (Centi)
import qualified Data.List as L
import qualified Data.List.NonEmpty as NE
import Data.Maybe (mapMaybe)
import Data.Ratio ((%))
import Data.Version (Version, showVersion)
import Data.Word (Word32, Word8)
import Debug.Trace (trace)
import qualified GHC.Exts as Exts
import GHC.Stack (HasCallStack)
import qualified Shamochu
import System.CPUTime (getCPUTime)
import System.Directory (createDirectoryIfMissing)
import System.FilePath ((<.>), (</>))

import UCD2Haskell.Common (
    Fold,
    distribute,
    rmapFold,
    runFold,
    showB,
    showPaddedHeXB,
 )

--------------------------------------------------------------------------------
-- Recipe
--------------------------------------------------------------------------------

data FileRecipe a
    = ModuleRecipe
      -- ^ A recipe to create a Haskell module file.
        { moduleName :: String
        -- ^ Module name
        , generateModule :: BB.Builder -> Fold a BB.Builder }
        -- ^ Function that generate the module, given the module name.
    -- May be useful someday
    -- TestOutputRecipe
    --   -- ^ A recipe to create a test output file.
    --     String
    --     -- ^ Test name
    --     (Fold a BB.Builder)
    --     -- ^ Test output generator

-- ModuleRecipe is a tuple of the module name and a function that generates the
-- module using the module name
type ModuleRecipe a = (String, BB.Builder -> Fold a BB.Builder)

type GeneratorRecipe a = [FileRecipe a]

--------------------------------------------------------------------------------
-- Generator
--------------------------------------------------------------------------------

moduleToFileName :: String -> String
moduleToFileName = map (\x -> if x == '.' then '/' else x)

dirFromFileName :: String -> String
dirFromFileName = reverse . dropWhile (/= '/') . reverse

moduleFileEmitter :: Version -> FilePath -> FilePath -> ModuleRecipe a -> Fold a (IO ())
moduleFileEmitter version unicodeSourceFile outdir (modName, fldGen) =
    rmapFold action $ fldGen (BB.string7 modName)

    where

    pretext = mconcat
        [ "-- autogenerated from https://www.unicode.org/Public/"
        , BB.string7 (showVersion version)
        , "/ucd/"
        , BB.string7 unicodeSourceFile
        ,"\n"
        ]
    outfile = outdir </> moduleToFileName modName <.> "hs"
    outfiledir = dirFromFileName outfile
    action c = do
        putChar '[' *> printCpuTime *> putStr "s] Writing module: "
        putStrLn modName
        createDirectoryIfMissing True outfiledir
        B.writeFile outfile (BL.toStrict (BB.toLazyByteString (pretext <> c)))

printCpuTime :: IO ()
printCpuTime = do
    t <- getCPUTime
    putStr (show (fromRational (t % 1000000000000) :: Centi))

runGenerator ::
       Version
    -> FilePath
    -> FilePath
    -> (B.ByteString -> [a])
    -> FilePath
    -> [String]
    -> GeneratorRecipe a
    -> IO ()
runGenerator version indir file transformLines outdir patterns recipes = do
    raw <- B.readFile (indir </> file)
    sequence_ (runFold combinedFld (transformLines raw))

    where

    generatedFolds = mapMaybe toModuleEmitter recipes
    toModuleEmitter = \case
      ModuleRecipe name f -> if all (`L.isSubsequenceOf` name) patterns
        then Just (moduleFileEmitter version file outdir (name, f))
        else Nothing
    combinedFld = distribute generatedFolds

--------------------------------------------------------------------------------
-- Header
--------------------------------------------------------------------------------

apacheLicense
    :: Word   -- ^ Copyright year
    -> BB.Builder -- ^ Module name
    -> BB.Builder
apacheLicense year modName =
    unlinesBB
        [ "-- |"
        , "-- Module      : " <> modName
        , "-- Copyright   : (c) "
            <> BB.wordDec year
            <> " Composewell Technologies and Contributors"
        , "-- License     : Apache-2.0"
        , "-- Maintainer  : streamly@composewell.com"
        , "-- Stability   : experimental"
        ]

--------------------------------------------------------------------------------
-- Bitmaps
--------------------------------------------------------------------------------

genBitmap :: HasCallStack => BB.Builder -> [Int] -> BB.Builder
genBitmap funcName ordList = mconcat
    [ "{-# INLINE " <> funcName <> " #-}\n"
    , funcName, " :: Char -> Bool\n"
    , funcName, func
    , "    !(Ptr bitmap#) = ", bitmapLookup, "\n\n"
    , bitmapLookup, " :: Ptr Word8\n"
    , bitmapLookup, " = Ptr\n"
    , "    \"", bitMapToAddrLiteral bitmap "\"#\n" ]
    where
    rawBitmap = positionsToBitMap ordList
    bitmapLookup = funcName <> "Bitmap"
    (func, bitmap) = if length rawBitmap <= 0x40000
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> let cp = ord c in cp >= 0x"
                , showPaddedHeXB (minimum ordList)
                , " && cp <= 0x"
                , showPaddedHeXB (maximum ordList)
                , " && lookupBit64 bitmap# cp\n"
                , "    where\n" ]
            , rawBitmap )
        -- Planes 0-3 and 14
        else
            let (planes0To3, plane14) = splitPlanes "genBitmap: cannot build" not rawBitmap
                bound0 = pred (minimum ordList)
                bound1 = length planes0To3
                bound2 = 0xE0000 + length plane14
            in ( mconcat
                    [ " c\n"
                    , if bound0 > 0
                        then mconcat
                            [ "    | cp < 0x"
                            , showPaddedHeXB bound0
                            , " = False\n" ]
                        else ""
                    , "    | cp < 0x", showPaddedHeXB bound1
                    , " = lookupBit64 bitmap# cp\n"
                    , "    | cp < 0xE0000 = False\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                    , " = lookupBit64 bitmap# (cp - 0x"
                    , showPaddedHeXB (0xE0000 - bound1)
                    , ")\n"
                    , "    | otherwise = False\n"
                    , "    where\n"
                    , "    cp = ord c\n" ]
                , planes0To3 <> plane14 )

positionsToBitMap :: [Int] -> [Bool]
positionsToBitMap = go 0

    where

    go _ [] = []
    go i xxs@(x:xs)
        | i < x = False : go (i + 1) xxs
        | otherwise = True : go (i + 1) xs

bitMapToAddrLiteral ::
  -- | Values to encode
  [Bool] ->
  -- | String to append
  BB.Builder ->
  BB.Builder
bitMapToAddrLiteral bs = chunkAddrLiteral 4 0xff encode (L.unfoldr mkChunks bs)

    where

    mkChunks :: [a] -> Maybe ([a], [a])
    mkChunks [] = Nothing
    mkChunks xs = Just $ splitAt 8 xs

    encode :: [Bool] -> BB.Builder -> BB.Builder
    encode chunk acc = BB.char7 '\\' <> BB.intDec (toByte (padTo8 chunk)) <> acc

    padTo8 :: [Bool] -> [Bool]
    padTo8 xs
        | length xs >= 8 = xs
        | otherwise = xs <> replicate (8 - length xs) False

    toByte :: [Bool] -> Int
    toByte xs = sum $ map (\i -> if xs !! i then 1 `shiftL` i else 0) [0..7]

splitPlanes :: (HasCallStack) => String -> (a -> Bool) -> [a] -> ([a], [a])
splitPlanes msg isDef xs = if all isDef planes4To13 && null planes15To16
    then (planes0To3, plane14)
    else error msg
    where
    planes0To3 = L.dropWhileEnd isDef (take 0x40000 xs)
    planes4To16 = drop 0x40000 xs
    planes4To13 = take (0xE0000 - 0x40000) planes4To16
    planes14To16 = drop (0xE0000 - 0x40000) planes4To16
    plane14 = L.dropWhileEnd isDef (take 0x10000 planes14To16)
    planes15To16 = drop 0x10000 planes14To16

genEnumBitmap
  :: forall a. (HasCallStack, Bounded a, Enum a, Eq a, Show a)
  => BB.Builder
  -- ^ Function name
  -> Bool
  -- ^ If true, use raw Int
  -> (a, BB.Builder)
  -- ^ Value for planes 15-16
  -> (a, BB.Builder)
  -- ^ Default value
  -> [a]
  -- ^ List of values to encode for planes 0 to 3
  -> [a]
  -- ^ List of values to encode for plane 14
  -> BB.Builder
genEnumBitmap funcName rawInt (defPUA, pPUA) (def, pDef) planes0To3 plane14 =
    mconcat
    [ "{-# INLINE ", funcName, " #-}\n"
    , funcName, " :: Char -> Int", rawSuffix, "\n"
    , funcName, func
    , "    !(Ptr bitmap#) = ", bitmapLookup, "\n\n"
    , bitmapLookup, " :: Ptr Word8\n"
    , bitmapLookup, " = Ptr\n"
    , "    \"", enumMapToAddrLiteral 4 0xff bitmap "\"#"
    ]
    where
    rawSuffix = if rawInt then "#" else ""
    bitmapLookup = funcName <> "Bitmap"
    planes0To3' = L.dropWhileEnd (== def) planes0To3
    check = if length planes0To3 <= 0x40000
        then ()
        else error "genEnumBitmap: Cannot build"
    (func, bitmap) = check `seq` if null plane14 && defPUA == def
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> let cp = ord c in if cp >= 0x"
                , showPaddedHeXB (length planes0To3')
                , " then "
                , pDef, rawSuffix
                , " else lookupWord8AsInt", rawSuffix, " bitmap# cp\n"
                , "    where\n" ]
            , planes0To3' )
        -- All the planes
        else
            let plane14' = L.dropWhileEnd (== def) plane14
                bound1 = length planes0To3'
                bound2 = 0xE0000 + length plane14'
            in ( mconcat
                    [ " c\n"
                    , "    -- Planes 0-3\n"
                    , "    | cp < 0x", showPaddedHeXB bound1
                                     , " = lookupWord8AsInt", rawSuffix, " bitmap# cp\n"
                    , "    -- Planes 4-13: ", showB def, "\n"
                    , "    | cp < 0xE0000 = " <> pDef, rawSuffix, "\n"
                    , "    -- Plane 14\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                                     , " = lookupWord8AsInt", rawSuffix, " bitmap# (cp - 0x"
                                     , showPaddedHeXB (0xE0000 - bound1)
                                     , ")\n"
                    , if defPUA == def
                        then ""
                        else mconcat
                            [ "    -- Plane 14: ", showB def, "\n"
                            , "    | cp < 0xF0000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB defPUA, "\n"
                            , "    | cp < 0xFFFFE = ", pPUA, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB def, "\n"
                            , "    | cp < 0x100000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 16: ", showB defPUA, "\n"
                            , "    | cp < 0x10FFFE = ", pPUA, rawSuffix, "\n" ]
                    , "    -- Default: ", showB def, "\n"
                    , "    | otherwise = " <> pDef, rawSuffix, "\n"
                    , "    where\n"
                    , "    cp = ord c\n" ]
                , planes0To3' <> plane14' )

{-| Encode a list of values as a byte map, using their 'Enum' instance.

__Note:__ 'Enum' instance must respect the following:

* @fromEnum minBound >= 0x00@
* @fromEnum maxBound <= 0xff@
-}
enumMapToAddrLiteral
  :: forall a. (Bounded a, Enum a, Show a)
  => Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
enumMapToAddrLiteral indentation chunkSize =
    chunkAddrLiteral indentation chunkSize addWord

    where

    addWord :: a -> BB.Builder -> BB.Builder
    addWord x acc = BB.char7 '\\' <> BB.word8Dec (toWord8 x) <> acc

    toWord8 :: a -> Word8
    toWord8 a = let w = fromEnum a in if 0 <= w && w <= 0xff
        then fromIntegral w
        else error $ "Cannot convert to Word8: " <> show a

-- | Encode a list of values as a byte map, using their 'Enum' instance.
enumMapToAddrLiteral'
  :: forall a. (Bounded a, Enum a, Show a)
  => Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> Word
  -- ^ Word per value
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
enumMapToAddrLiteral' indentation chunkSize size =
    chunkAddrLiteral indentation chunkSize addWords

    where

    upperBound = 1 `shiftL` (8 * fromIntegral size)

    addWords :: a -> BB.Builder -> BB.Builder
    addWords x acc = foldMap (\w -> BB.char7 '\\' <> BB.word8Dec w) (toWord8LEs x) <> acc

    toWord8LEs :: a -> [Word8]
    toWord8LEs a = let w = fromEnum a in if 0 <= w && w < upperBound
        then go size w
        else error $ "Cannot convert to Word8s: " <> show a <> " " <> show (size, upperBound)

    go 0 _ = []
    go k n = fromIntegral (n .&. 0xff) : go (k - 1) (n `shiftR` 8)

chunkAddrLiteral
  :: forall a. Word8
  -- ^ Indentation
  -> Int
  -- ^ Chunk size
  -> (a -> BB.Builder -> BB.Builder)
  -- ^ Function to convert to 'Word8' and prepend to the accumulator
  -> [a]
  -- ^ Values to encode
  -> BB.Builder
  -- ^ String to append
  -> BB.Builder
chunkAddrLiteral indentation chunkSize addWord xs cs
    = fst
    . foldr go (cs, NoIndent)
    $ chunksOf chunkSize xs

    where

    indent = indent' indentation . (BB.char7 '\\' <>)
    indent' = \case
        0 -> (BB.shortByteString "\\\n" <>)
        i -> indent' (pred i) . (BB.char7 ' ' <>)

    go :: [a] -> (BB.Builder, Indent) -> (BB.Builder, Indent)
    go as (acc, seps) = (foldr addWord (f acc) as, Indent)
        where
        f = case seps of
            NoIndent -> id
            Indent -> indent

data Indent = NoIndent | Indent

chunksOf :: Int -> [a] -> [[a]]
chunksOf i = go
    where
    go = \case
        [] -> []
        as -> b : go as'
            where (b, as') = splitAt i as

-- Encode Word32 to [Word8] little endian
word32ToWord8s :: Word32 -> [Word8]
word32ToWord8s n = (\k -> fromIntegral ((n `shiftR` k) .&. 0xff)) <$> [0,8..24]

--------------------------------------------------------------------------------
-- Bitmaps: Shamochu algorithm
--------------------------------------------------------------------------------

genEnumBitmapShamochu
  :: forall a. (HasCallStack, Bounded a, Enum a, Eq a, Show a)
  => String
  -- ^ Function name
  -> Bool
  -- ^ If true, use raw Int
  -> NE.NonEmpty Word
  -- ^ Chunk size stage 1
  -> [Word]
  -- ^ Chunk size stage 2
  -> (a -> Word8)
  -- ^ Conversion
  -> (a, BB.Builder)
  -- ^ Value for planes 15-16
  -> (a, BB.Builder)
  -- ^ Default value
  -> [a]
  -- ^ List of values to encode for planes 0 to 3
  -> [a]
  -- ^ List of values to encode for plane 14
  -> BB.Builder
genEnumBitmapShamochu funcNameStr rawInt stage1 stage2 convert (defPUA, pPUA) (def, pDef) planes0To3 plane14 =
    mconcat
    [ "{-# INLINE ", funcName, " #-}\n"
    , funcName, " :: Char -> Int", rawSuffix, "\n"
    , funcName, func
    , "\n"
    , generateShamochuBitmaps funcNameStr rawInt stage1 stage2 convert bitmap
    ]
    where
    rawSuffix = if rawInt then "#" else ""
    funcName = BB.string7 funcNameStr
    lookupFunc = toLookupBitMapName funcNameStr
    planes0To3' = L.dropWhileEnd (== def) planes0To3
    check = if length planes0To3 <= 0x40000
        then ()
        else error "genEnumBitmap: Cannot build"
    (func, bitmap) = check `seq` if null plane14 && defPUA == def
        -- Only planes 0-3
        then
            ( mconcat
                [ " = \\c -> if c >= '\\x"
                , showPaddedHeXB (length planes0To3')
                , "' then "
                , pDef, rawSuffix
                , " else ", lookupFunc, " (ord c)\n" ]
            , planes0To3' )
        -- All the planes
        else
            let plane14' = L.dropWhileEnd (== def) plane14
                bound1 = length planes0To3'
                bound2 = 0xE0000 + length plane14'
            in ( mconcat
                    [ " c\n"
                    , "    -- Planes 0-3\n"
                    , "    | cp < 0x", showPaddedHeXB bound1
                                     , " = ", lookupFunc, " cp", rawSuffix, "\n"
                    , "    -- Planes 4-13: ", showB def, "\n"
                    , "    | cp < 0xE0000 = " <> pDef, rawSuffix, "\n"
                    , "    -- Plane 14\n"
                    , "    | cp < 0x", showPaddedHeXB bound2
                                     , " = ", lookupFunc, " (cp", rawSuffix
                                     , " -", rawSuffix, " 0x"
                                     , showPaddedHeXB (0xE0000 - bound1), rawSuffix
                                     , ")\n"
                    , if defPUA == def
                        then ""
                        else mconcat
                            [ "    -- Plane 14: ", showB def, "\n"
                            , "    | cp < 0xF0000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB defPUA, "\n"
                            , "    | cp < 0xFFFFE = ", pPUA, rawSuffix, "\n"
                            , "    -- Plane 15: ", showB def, "\n"
                            , "    | cp < 0x100000 = ", pDef, rawSuffix, "\n"
                            , "    -- Plane 16: ", showB defPUA, "\n"
                            , "    | cp < 0x10FFFE = ", pPUA, rawSuffix, "\n" ]
                    , "    -- Default: ", showB def, "\n"
                    , "    | otherwise = " <> pDef, rawSuffix, "\n"
                    , "    where\n"
                    , "    ", if rawInt then "!cp@(I# cp#)" else "cp", " = ord c\n" ]
                , planes0To3' <> plane14' )

generateShamochuBitmaps ::
    String -> Bool -> NE.NonEmpty Word -> [Word] -> (a -> Word8) -> [a] -> BB.Builder
generateShamochuBitmaps name rawInt powersStage1 powersStage2 convert xs =
    case Shamochu.compress powersStage1 powersStage2 (Exts.fromList (convert <$> xs)) of
        Shamochu.OneStage{..} -> trace' "OneStage" stats $ mconcat
            [ "{-# INLINE ", toLookupBitMapName name, " #-}\n"
            , toLookupBitMapName name, " :: Int", rawSuffix, " -> Int", rawSuffix, "\n"
            , toLookupBitMapName name, " n =\n"
            -- Lookup:
            --    mask = (1 << chunk_size_log2) - 1;
            --    original[i] = data[offsets[i >> chunk_size_log2] + (i & mask)];
            , mkLookup (Shamochu.dataIntSize stats) "data" 1 . mconcat $
                [ mkLookup (Shamochu.offsets1IntSize stats) "offsets" 2 $
                    mkIndent 3 <> mkShiftR "n" (Shamochu.dataChunkSizeLog2 stats)
                , mkAnd "n" "mask" ]
            , "\n"
            , "    where\n"
            , "    ", mkMask "mask" (Shamochu.dataChunkSizeLog2 stats)
            , "    !(Ptr data#) = ", dataBitMap, "\n"
            , "    !(Ptr offsets#) = ", offsetsBitMap, "\n"
            , "\n"
            , dataBitMap, " :: Ptr ", dataType, "\n"
            , dataBitMap, " = Ptr\n"
            , "    \"", enumMapToAddrLiteral'
                            4
                            50
                            (Shamochu.dataIntSize stats `shiftR` 3)
                            (Exts.toList array)
                            "\"#\n"
            , "\n"
            , offsetsBitMap, " :: Ptr ", offsetType, "\n"
            , offsetsBitMap, " = Ptr\n"
            , "    \"", enumMapToAddrLiteral'
                            4
                            50
                            (Shamochu.offsets1IntSize stats `shiftR` 3)
                            (Exts.toList offsets)
                            "\"#\n"
            ]
            where
            Shamochu.CompressedArray{..} = array1
            dataBitMap = nameBB <> "DataBitMap"
            offsetsBitMap = nameBB <> "OffsetsBitMap"
            dataType = "Int" <> BB.wordDec (Shamochu.dataIntSize stats)
            offsetType = "Word" <> BB.wordDec (Shamochu.offsets1IntSize stats)
        Shamochu.TwoStages{..} -> trace' "TwoStages" stats $ mconcat
            [ "{-# INLINE ", toLookupBitMapName name, " #-}\n"
            , toLookupBitMapName name, " :: Int", rawSuffix, " -> Int", rawSuffix, "\n"
            , toLookupBitMapName name, " n =\n"
            -- Lookup:
            --    mask_data = (1 << data_chunk_size_log2) - 1
            --    mask_offsets = (1 << offsets_chunk_size_log2) - 1
            --    data[
            --        offsets1[
            --            offsets2[ks >> (data_chunk_size_log2 + offsets_chunk_size_log2)] +
            --            ((ks >> data_chunk_size_log2) & mask_offsets)
            --        ] +
            --        (ks & mask_data)
            --    ];
            , mkLookup (Shamochu.dataIntSize stats) "data" 1 . mconcat $
                [ mkLookup (Shamochu.offsets1IntSize stats) "offsets1" 2 . mconcat $
                    [ mkLookup (Shamochu.offsets2IntSize stats) "offsets2" 3 $
                        mkIndent 4 <>
                        mkShiftR "n" (Shamochu.dataChunkSizeLog2 stats + Shamochu.offsets1ChunkSizeLog2 stats)
                    , mkAnd ("(" <> mkShiftR "n" (Shamochu.dataChunkSizeLog2 stats) <> ")") "maskOffsets"
                    ]
                , mkAnd "n" "maskData" ]
            , "\n"
            , "    where\n"
            , "    ", mkMask "maskData" (Shamochu.dataChunkSizeLog2 stats)
            , "    ", mkMask "maskOffsets" (Shamochu.offsets1ChunkSizeLog2 stats)
            , "    !(Ptr data#) = ", dataBitMap, "\n"
            , "    !(Ptr offsets1#) = ", offsets1BitMap, "\n"
            , "    !(Ptr offsets2#) = ", offsets2BitMap, "\n"
            , "\n"
            , dataBitMap, " :: Ptr ", dataType, "\n"
            , dataBitMap, " = Ptr\n"
            , "    \"", enumMapToAddrLiteral'
                            4
                            50
                            (Shamochu.dataIntSize stats `shiftR` 3)
                            (Exts.toList dataArray)
                            "\"#\n"
            , "\n"
            , offsets1BitMap, " :: Ptr ", offset1Type, "\n"
            , offsets1BitMap, " = Ptr\n"
            , "    \"", enumMapToAddrLiteral'
                            4
                            50
                            (Shamochu.offsets1IntSize stats `shiftR` 3)
                            (Exts.toList offset1Array)
                            "\"#\n"
            , "\n"
            , offsets2BitMap, " :: Ptr ", offset2Type, "\n"
            , offsets2BitMap, " = Ptr\n"
            , "    \"", enumMapToAddrLiteral'
                            4
                            50
                            (Shamochu.offsets2IntSize stats `shiftR` 3)
                            (Exts.toList offsets2Array)
                             "\"#\n"
            ]
            where
            Shamochu.CompressedArray{array=dataArray} = array1
            Shamochu.CompressedArray{array=offset1Array, offsets=offsets2Array} = array2
            dataBitMap = nameBB <> "DataBitMap"
            offsets1BitMap = nameBB <> "Offsets1BitMap"
            offsets2BitMap = nameBB <> "Offsets2BitMap"
            dataType = "Int" <> BB.wordDec (Shamochu.dataIntSize stats)
            offset1Type = "Word" <> BB.wordDec (Shamochu.offsets1IntSize stats)
            offset2Type = "Word" <> BB.wordDec (Shamochu.offsets2IntSize stats)
    where
    rawSuffix = if rawInt then "#" else ""
    trace' stages stats = trace $ mconcat
        [ "* ", name, ": Shamochu: ", stages, "; savings: "
        , show (fromRational (100 * (1 - 1 / toRational (Shamochu.ratio stats))) :: Centi)
        , "%; "
        , show stats ]
    nameBB = BB.string7 name
    mkIndent :: Word -> BB.Builder
    mkIndent count = foldMap (const "    ") [1..count]
    mkLookup dataSize addrName indent index = mconcat
        [ mkIndent indent
        , "lookupWord", BB.wordDec dataSize, "AsInt", rawSuffix, " ", addrName, "# (\n"
        , index, "\n"
        , mkIndent indent, ")" ]
    mkMask mask count = if rawInt
        then mconcat [mask, " = (1# `iShiftL#` ", BB.wordDec count, "#) -# 1#\n"]
        else mconcat [mask, " = (1 `shiftL` ", BB.wordDec count, ") - 1\n"]
    mkShiftR n count = if rawInt
        then mconcat [n, " `iShiftRL#` ", BB.wordDec count, "#"]
        else mconcat [n, " `shiftR` ", BB.wordDec count]
    mkAnd n mask = if rawInt
        then mconcat [" +# (", n, " `andI#` ", mask, ")"]
        else mconcat [" + (", n, " .&. ", mask, ")"]

toTitle :: String -> String
toTitle = \case
    c:cs -> toUpper c : cs
    cs -> cs

toLookupBitMapName :: String -> BB.Builder
toLookupBitMapName name = "lookup" <> BB.string7 (toTitle name) <> "BitMap"

--------------------------------------------------------------------------------
-- Helpers
--------------------------------------------------------------------------------

unlinesBB :: [BB.Builder] -> BB.Builder
unlinesBB = (<> "\n") . mconcat . L.intersperse "\n"

unwordsBB :: [BB.Builder] -> BB.Builder
unwordsBB = mconcat . L.intersperse " "
